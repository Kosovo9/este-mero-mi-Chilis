import { GoogleGenAI } from "@google/genai";
import { MODEL_NAME, PROMPT_MAESTRO_BASES, SUBJECT_BLOCKS, NEGATIVE_PROMPT, IDENTITY_LOCK, PROMPT_ROUTER_SYSTEM } from "../constants";
import { SubjectType, StyleOption } from "../types";

export const generateChristmasImage = async (
  base64Image: string,
  style: StyleOption,
  subjectType: SubjectType,
  customPromptText?: string
): Promise<string> => {
  try {
    const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
    
    const base = PROMPT_MAESTRO_BASES[style.category];
    const subject = SUBJECT_BLOCKS[subjectType];
    const scene = style.isCustom ? customPromptText : style.promptSnippet;
    
    // Constructing the final prompt according to Prompt Maestro v3 + Prompt Router rules
    const fullPrompt = `
      ${PROMPT_ROUTER_SYSTEM}
      
      ${base}
      
      ${subject}
      
      ${scene}
      
      ${IDENTITY_LOCK}
      
      ${NEGATIVE_PROMPT}
      
      Final Quality Instruction: Generate the most premium, cinematic 8K version possible. 
      Ensure zero artifacts on face. Remove all office equipment.
    `;

    const cleanBase64 = base64Image.replace(/^data:image\/(png|jpeg|jpg|webp);base64,/, '');

    // We fetch the style thumbnail to use it as the "STYLE ONLY" reference for Gemini
    let styleImagePart: any = null;
    try {
        const styleImgResponse = await fetch(style.imageSrc);
        const styleBlob = await styleImgResponse.blob();
        const styleBase64 = await new Promise<string>((resolve) => {
            const reader = new FileReader();
            reader.onloadend = () => resolve(reader.result as string);
            reader.readAsDataURL(styleBlob);
        });
        const cleanStyleBase64 = styleBase64.replace(/^data:image\/(png|jpeg|jpg|webp);base64,/, '');
        
        styleImagePart = {
            inlineData: {
                mimeType: "image/jpeg",
                data: cleanStyleBase64
            }
        };
    } catch (e) {
        console.warn("Could not fetch style thumbnail, proceeding with user image only", e);
    }

    const contents: any = {
        parts: [
            {
                inlineData: {
                    mimeType: "image/jpeg",
                    data: cleanBase64
                }
            },
            {
                text: fullPrompt
            }
        ]
    };

    // If we successfully fetched the style reference, add it as a second image part
    if (styleImagePart) {
        contents.parts.splice(1, 0, styleImagePart);
    }

    const response = await ai.models.generateContent({
      model: MODEL_NAME,
      contents: contents,
      config: {
        temperature: 0.7,
        topK: 64,
        topP: 0.95,
      }
    });

    const parts = response.candidates?.[0]?.content?.parts;
    if (parts) {
      for (const part of parts) {
        if (part.inlineData?.data) {
          return `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`;
        }
      }
    }
    
    throw new Error("No image generated by the AI model");
  } catch (error) {
    console.error("Gemini Image Generation Error:", error);
    throw error;
  }
};
